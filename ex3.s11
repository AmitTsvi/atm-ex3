. = torg + 5000
 
		
main:		mov pc, sp				;start a stack
			tst -(sp)
			
			;"Check Image Dimensions" - checks that the image have positive dimensisons.
			tstb nCols				
			bgt chkRows				;continue only if the number of rows is greater than 0
			jmp @#finish
chkRows:	tstb nRows
			bgt continue			;continue only if the number of columns is greater than 0
			jmp @#finish
	

			
			;"Using isLegal" - checks that the two input images have leagal byte values (0-17).
continue:	clr r1
			mov #OrigImg, r1
			clr r2
			movb nRows, r2
			clr r3
			movb nCols, r3
			mov #2, r4				;the register contains the number of iterations - 2 iterations - 1 for each image
checkImg2:	mov r1, 14(pc)			;passing address the image to be tested (inline)
			mov r2, 12(pc)			;passing number of rows (inline)
			mov r3, 10(pc)			;passing number of columns (inline)
			jsr r5, isLegal			;calling isLegal
			.word 0					;space for the inline parameter - address of image
			.word 0					;space for the inline parameter - nRows
			.word 0					;space for the inline parameter - nCols
			.word 0					;place for the result of  isLegal routine
			tst -6(pc)
			beq chkEncImg			;if isLegal result != 0 - exit
			jmp @#finish
chkEncImg:	mov #EncImg, r1			;switch the address in r1 to the address of the encrypted image
			sob r4, checkImg2
			
			;"Using system" - finding the correct key using system subroutine
			mov #OrigImg, -(sp)		;passing arguments in stack to system
			mov #EncImg, -(sp)
			mov nRows, -(sp)
			mov nCols, -(sp)
			mov #Hash, -(sp)
			jsr pc, system
			cmp (sp)+, (sp)+		;popping the stack - 5 inputs in stack and 0 outputs - 5 pops
			cmp (sp)+, (sp)+
			tst (sp)+
			halt					;TO_DO: CHECK THAT THE STACK IS EMPTY IN THE END!
			
			;"System" (Procedure) - finds the key that was used to encrypt OrigImg the made EncImg.
			;inputs - address of the original image - in stack
			;		- address of encrypted image - in stack
			;		- number of rows in the image - in stack
			;		- number of columns in the image - in stack
			;		- address of the scrumbling function used in the proccess of encryption of original image
			;		- address of the start of key's list - in common area
			;outputs- result key - writen in the list that was passed as input in common area
system:		mov r1, -(sp)			;saving r1 original value on stack
			mov #Key, r1			;moving the address Key to r1
checkNext:	jsr pc, nextKey			;calling nextKey

			;"Encrypt" - encrypting the original image
			
			
			;"Comapte Images" - comparing the new encrypted image to the input encrypted image
			mov #0, -(sp)			;space for cmpImg result
			mov #OrigImg, -(sp)		;passing input parameters for cmpImg in stack
			mov #EncImg, -(sp)
			clr -2(sp)
			movb nRows, -(sp)
			clr -2(sp)
			movb nCols, -(sp)
			jsr pc, cmpImg
			cmp (sp)+, (sp)+		;popping the stack - 4 inputs and 0 outputs - 5 pops
			cmp (sp)+, (sp)+
			tst (sp)+
						
			beq systemFin			;if identical jump to systemfinish
			
			;"Decrypt" - decrypting the new encrypted image (going back to the original input image)
			
			br checkNext			;stating another iteration of key checking proccess with the next key
			
systemFin:	mov (sp)+, r1			;restoring r1
			halt					;done
			
			;"nextKey" (Procedure) - changes the given key to the next key. the first node is increased by 1.
			;if node 'i' is '17' it moves to '0' (only if is needs to be in icremented) and the next node 'i+1' is increased by 1.
			;inputs - address of the start of key's list - in register r1
			;outputs- next key - writen in the list that was passed as input in r1
nextKey:	mov r2, -(sp)			;pushing the content of r2 to the stack
			mov r1, -(sp)			;pushing the address of the key to the stack
			jsr pc, recurseKey		;calling recurseKey
			tst (sp)+				;popping 
			mov (sp)+, r2			;restoring the content of r2 from the stack
recurseKey:	cmp @2(sp), #17			
			beq nextCall			;if the key element equals 17 go to nextCall
			inc @2(sp)				;if the key element does no equal 17 simply add 1
			br finishKey			;go to finishKey
nextCall:	mov 0, @2(sp)			;key element = 0
			mov 2(sp), r2			;copy the address of the current key element to r2
			add #2, r2				;add 2 to r2 - now r2 contains the address of the address of the adress of the next key element
			mov (r2), -(sp)			;push the address of the next key element
			jsr pc, recurseKey		;calling nextCall (recursion)
finishKey:	rts pc					;return from recurseKey
		
cmpImg:		mov r0, -(sp)			;the picture isn't empty
			mov r1, -(sp)
			mov r2, -(sp) 			;saving register values in stack
			mov 8(sp), r0 			;columns to register r0 - assuming that was saved in words
			mov 10(sp), r1			;rows to register r1 - assuming that was saved in words
			mul r1, r0				;number of bytes saved in r0
			mov 14(sp), r1			;first picture address in r1
			mov 12(sp), r2			;second picture address in r2
cmpImgLoop:	cmpb (r1),(r2)			;comparing two bytes in a picture
			bne notSameImg			
			dec r0
			beq sameImg
			cmpb (r1)+, (r2)+ 		;dummy just to advance the pointer to the next bytes of the picture
			br cmpImgLoop
notSameImg:	mov #1, 16(sp)			;output returns in stack
			mov (sp)+, r2
			mov (sp)+, r1
			mov (sp)+, r0			;restoring registers
			rts pc
sameImg:		mov #0, 16(sp)			;output returns in stack
			mov (sp)+, r2
			mov (sp)+, r1
			mov (sp)+, r0			;restoring registers
			rts pc

isLegal:		mov r0, -(sp)			;the picture isn't empty
			mov r1, -(sp)
			mov r2, -(sp) 			;saving register values in stack
			mov (r5)+, r2			;picture's address moved to register r2 
			mov (r5)+, r0 			;rows passing to r0 - assuming that was saved in words
			mov (r5)+, r1			;columns passing to r1 - assuming that was saved in words
			mul r0, r1		
isLegalLoop:cmpb (r2), #17
			bgt notLegal			;branch if bigger then 15 or smaller then 0
			tstb (r2)+
			blt notLegal
			dec r1
			beq legal				;branch if r0 is 0 - picture is all scanned
			br isLegalLoop
notLegal:	mov #1, (r5)+			;note that here 1 in returned when the picture is notLegal
			mov (sp)+, r2
			mov (sp)+, r1
			mov (sp)+, r0 			;restoring registers
			rts r5
legal:   	mov #0, (r5)+			;returning 0 when legal
			mov (sp)+, r2
			mov (sp)+, r1
			mov (sp)+, r0			;restoring registers
			rts r5
			
finish:		halt
		
		
.= torg + 11000
nCols: 		.byte 10
nRows: 	.byte 4
OrigImg: 	.byte	 1,  2,  1,  2, 0,   1,   2,    3 
				.byte	 3,  4,  3,  4, 4,   5,   6,    7
				.byte	 5,  6,  5,  6, 10, 11, 12, 13
				.byte	 7,  0,  7,  0, 14, 15, 16, 17
EncImg: 	.byte	 3,  4,  3,  4,  2,  3,   4,    5 
				.byte	 7,  4,  7,  4,  10,   7,   6,    11
				.byte	 7,  10,  7,  10, 14, 15, 12, 13
				.byte	 3,  10,  3,  10, 16, 1, 0, 17
Hash:		.byte 	2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
.even
Key:		
node1:		.word -1, node2
node2:		.word -1, node3
node3:		.word -1, 0